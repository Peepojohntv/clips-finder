<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>Twitch Clip Finder</title>

  <style>
    :root{
      --bg0:#07070c;
      --bg1:#0e0e16;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.045);
      --stroke: rgba(255,255,255,.10);
      --stroke2: rgba(255,255,255,.14);
      --text:#f2f2f5;
      --muted: rgba(242,242,245,.70);
      --muted2: rgba(242,242,245,.52);
      --accent:#9146ff;
      --accent2:#b489ff;
      --good:#4ade80;
      --bad:#fb7185;
      --warn:#fbbf24;

      --r16: 16px;
      --r14: 14px;
      --r12: 12px;

      --shadow: 0 22px 70px rgba(0,0,0,.55);
      --shadow2: 0 12px 28px rgba(0,0,0,.45);

      --ease: cubic-bezier(.2,.8,.2,1);
      --blur: blur(14px);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(145,70,255,.18), transparent 60%),
        radial-gradient(900px 600px at 85% 20%, rgba(180,137,255,.12), transparent 55%),
        radial-gradient(700px 520px at 50% 92%, rgba(145,70,255,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x: hidden;
    }

    .grain{
      pointer-events:none;
      position: fixed;
      inset: -40%;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.25'/%3E%3C/svg%3E");
      opacity: .10;
      mix-blend-mode: overlay;
      transform: rotate(12deg);
      animation: grainMove 10s linear infinite;
    }
    @keyframes grainMove{
      0%{ transform: translate3d(0,0,0) rotate(12deg); }
      100%{ transform: translate3d(-6%, -6%, 0) rotate(12deg); }
    }

    .app{
      max-width: 1400px;
      margin: 0 auto;
      padding: 18px;
      animation: enter .6s var(--ease) both;
    }
    @keyframes enter{
      from{ opacity: 0; transform: translateY(10px); }
      to{ opacity: 1; transform: translateY(0); }
    }

    /* topbar */
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      margin-bottom: 14px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 280px;
    }
    .logo{
      width: 38px; height: 38px;
      border-radius: 12px;
      background: radial-gradient(80% 80% at 30% 25%, rgba(255,255,255,.25), transparent 60%),
                  linear-gradient(180deg, var(--accent), #6d28d9);
      box-shadow: 0 16px 40px rgba(145,70,255,.25);
      position: relative;
      overflow:hidden;
    }
    .logo::after{
      content:"";
      position:absolute; inset:-40%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.35), transparent 55%);
      transform: rotate(18deg);
      animation: logoShine 3.8s var(--ease) infinite;
      opacity:.8;
    }
    @keyframes logoShine{
      0%, 45% { transform: translateX(-10%) translateY(0) rotate(18deg); opacity: .5; }
      55%,100%{ transform: translateX(18%) translateY(-8%) rotate(18deg); opacity: .9; }
    }

    .brand h1{
      margin:0;
      font-size: 15px;
      letter-spacing: .2px;
      font-weight: 850;
    }
    .brand p{
      margin: 2px 0 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
      max-width: 560px;
    }

    .actions{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .nav{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 6px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      box-shadow: var(--shadow2);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
    }
    .tab{
      border:0;
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      color: rgba(242,242,245,.85);
      background: transparent;
      font-weight: 750;
      font-size: 13px;
      transition: background .16s var(--ease), transform .16s var(--ease), color .16s var(--ease);
      display:flex;
      align-items:center;
      gap: 8px;
      user-select:none;
    }
    .tab:hover{ background: rgba(255,255,255,.06); }
    .tab[aria-selected="true"]{
      background: linear-gradient(180deg, rgba(145,70,255,.30), rgba(145,70,255,.14));
      outline: 1px solid rgba(145,70,255,.35);
      color: white;
    }

    /* buttons */
    .btn{
      border:0;
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 850;
      color: white;
      background: linear-gradient(180deg, var(--accent), #6d28d9);
      box-shadow: 0 14px 32px rgba(145,70,255,.20);
      transition: transform .14s var(--ease), filter .14s var(--ease), opacity .14s var(--ease);
      display:inline-flex;
      gap: 8px;
      align-items:center;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.04); }
    .btn:active{ transform: translateY(0px); filter: brightness(.98); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; transform:none; filter:none; }

    .btnGhost{
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow:none;
      color: rgba(242,242,245,.88);
    }
    .btnGhost:hover{ background: rgba(255,255,255,.10); }

    /* account chip top right */
    .account{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      box-shadow: var(--shadow2);
      max-width: 360px;
    }
    .avatar{
      width: 28px; height: 28px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      overflow:hidden;
      flex: 0 0 auto;
    }
    .avatar img{ width:100%; height:100%; object-fit:cover; display:block; }
    .accountText{
      display:flex;
      flex-direction:column;
      gap: 1px;
      min-width: 0;
    }
    .accountText .name{
      font-weight: 900;
      font-size: 12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .accountText .sub{
      font-size: 11px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* shell: sidebar + content */
    .shell{
      display:grid;
      grid-template-columns: 280px 1fr;
      gap: 14px;
      align-items:start;
    }

    .card{
      border-radius: var(--r16);
      background: var(--panel);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      overflow:hidden;
    }
    .cardHeader{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .cardHeader h2{
      margin:0;
      font-size: 13px;
      letter-spacing: .2px;
      font-weight: 900;
      color: rgba(242,242,245,.92);
    }
    .cardBody{ padding: 12px; }

    /* forms */
    label{
      display:block;
      margin: 10px 0 6px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 750;
    }
    input, select{
      width:100%;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(10,10,14,.62);
      color: var(--text);
      outline:none;
      transition: box-shadow .16s var(--ease), border-color .16s var(--ease), background .16s var(--ease);
      font-size: 14px;
    }
    input:focus, select:focus{
      border-color: rgba(145,70,255,.65);
      box-shadow: 0 0 0 4px rgba(145,70,255,.14);
      background: rgba(0,0,0,.50);
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .muted{
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.45;
      margin-top: 10px;
    }

    /* status/error */
    .statusLine{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      color: var(--muted);
      font-size: 13px;
      min-height: 22px;
    }
    .busy{
      display:none;
      align-items:center;
      gap: 8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size: 12px;
    }
    .spinner{
      width: 14px; height: 14px;
      border-radius: 999px;
      border: 2px solid rgba(242,242,245,.22);
      border-top-color: var(--accent2);
      animation: spin .85s linear infinite;
    }
    @keyframes spin { to{ transform: rotate(360deg);} }

    .err{
      margin-top: 10px;
      color: var(--bad);
      white-space: pre-wrap;
      font-size: 13px;
      line-height: 1.35;
      font-weight: 750;
    }

    /* results grid */
    .results{
      padding: 12px;
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 12px;
      animation: fadeIn .18s var(--ease) both;
    }
    @keyframes fadeIn{
      from{ opacity: 0; transform: translateY(4px); }
      to{ opacity: 1; transform: translateY(0); }
    }

    .clip{
      display:block;
      border-radius: 16px;
      overflow:hidden;
      text-decoration:none;
      color: inherit;
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 36px rgba(0,0,0,.25);
      transform: translateZ(0);
      transition: transform .16s var(--ease), border-color .16s var(--ease), background .16s var(--ease);
    }
    .clip:hover{
      transform: translateY(-3px);
      border-color: rgba(145,70,255,.38);
      background: rgba(0,0,0,.22);
    }
    .thumbWrap{
      position:relative;
      background: rgba(255,255,255,.05);
      aspect-ratio: 16 / 9;
      overflow:hidden;
      border-bottom: 1px solid rgba(255,255,255,.07);
    }
    .thumb{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      transform: scale(1.02);
      transition: transform .35s var(--ease), filter .35s var(--ease);
      filter: saturate(1.05) contrast(1.03);
    }
    .clip:hover .thumb{ transform: scale(1.06); filter: saturate(1.12) contrast(1.05); }
    .thumbGrad{
      position:absolute; inset:auto 0 0 0;
      height: 52%;
      background: linear-gradient(180deg, transparent, rgba(0,0,0,.55));
      pointer-events:none;
    }
    .clipBody{
      padding: 12px;
    }
    .clipTitle{
      margin: 0 0 10px;
      font-size: 13.5px;
      line-height: 1.25;
      letter-spacing: .1px;
      font-weight: 900;
      color: rgba(242,242,245,.96);
      display:-webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow:hidden;
    }
    .meta{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.4;
    }
    .tag{
      display:inline-flex;
      gap: 6px;
      align-items:center;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
    }
    .tag strong{ color: rgba(242,242,245,.78); font-weight: 900; }

    /* skeleton */
    .skeleton{
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
    }
    .skThumb{ aspect-ratio: 16/9; position:relative; overflow:hidden; background: rgba(255,255,255,.05); }
    .skLine{ height: 10px; margin: 10px 12px; border-radius: 999px; background: rgba(255,255,255,.06); position:relative; overflow:hidden; }
    .skLine.small{ width: 62%; }
    .shimmer::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.08), transparent);
      transform: translateX(-100%);
      animation: shimmer 1.1s linear infinite;
    }
    @keyframes shimmer{
      0%{ transform: translateX(-100%); }
      100%{ transform: translateX(100%); }
    }

    /* sidebar */
    .sideTop{
      display:flex;
      gap: 8px;
      align-items:center;
    }
    .sideTabs{
      display:flex;
      gap: 6px;
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .sideTab{
      border:0;
      padding: 8px 10px;
      border-radius: 999px;
      background: transparent;
      color: rgba(242,242,245,.85);
      cursor:pointer;
      font-weight: 850;
      font-size: 12px;
    }
    .sideTab[aria-selected="true"]{
      background: rgba(255,255,255,.08);
      outline: 1px solid rgba(255,255,255,.10);
      color: white;
    }

    .chanList{
      display:flex;
      flex-direction:column;
      gap: 8px;
      margin-top: 10px;
      max-height: calc(100vh - 220px);
      overflow:auto;
      padding-right: 4px;
    }
    .chan{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      cursor:pointer;
      transition: transform .14s var(--ease), background .14s var(--ease), border-color .14s var(--ease);
    }
    .chan:hover{
      transform: translateY(-1px);
      border-color: rgba(145,70,255,.28);
      background: rgba(0,0,0,.20);
    }
    .chanAva{
      width: 34px; height: 34px;
      border-radius: 999px;
      overflow:hidden;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      flex: 0 0 auto;
    }
    .chanAva img{ width:100%; height:100%; object-fit:cover; display:block; }
    .chanTxt{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap: 2px;
    }
    .chanTxt .t{
      font-weight: 900;
      font-size: 12.5px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .chanTxt .s{
      font-size: 11px;
      color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .badgeLive{
      margin-left:auto;
      font-size: 11px;
      font-weight: 900;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      color: rgba(242,242,245,.86);
      white-space:nowrap;
    }

    /* drawer settings */
    .drawerBackdrop{
      position: fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s var(--ease);
      z-index: 40;
    }
    .drawer{
      position: fixed;
      top:0; right:0;
      width: min(520px, 92vw);
      height: 100vh;
      background: rgba(12,12,18,.92);
      border-left: 1px solid rgba(255,255,255,.10);
      box-shadow: -30px 0 80px rgba(0,0,0,.55);
      transform: translateX(105%);
      transition: transform .20s var(--ease);
      overflow:auto;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      z-index: 41;
    }
    .drawerOpen .drawerBackdrop{ opacity:1; pointer-events:auto; }
    .drawerOpen .drawer{ transform: translateX(0); }

    .drawerHead{
      position: sticky;
      top:0;
      padding: 14px;
      background: rgba(12,12,18,.88);
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      z-index: 2;
    }
    .drawerHead h3{
      margin:0;
      font-size: 14px;
      font-weight: 950;
    }
    .drawerBody{ padding: 14px; }

    .section{
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .section h4{
      margin: 0 0 10px;
      font-size: 12px;
      color: rgba(242,242,245,.86);
      letter-spacing:.2px;
      font-weight: 950;
      text-transform: uppercase;
    }

    /* toast */
    .toasts{
      position: fixed;
      right: 16px;
      bottom: 16px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      z-index: 60;
    }
    .toast{
      width: min(420px, calc(100vw - 32px));
      border-radius: 16px;
      padding: 12px;
      background: rgba(0,0,0,.50);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      animation: toastIn .22s var(--ease) both;
    }
    @keyframes toastIn{
      from{ opacity:0; transform: translateY(8px); }
      to{ opacity:1; transform: translateY(0); }
    }
    .toast strong{ display:block; font-size: 13px; font-weight: 950; margin-bottom: 2px; }
    .toast span{ color: var(--muted); font-size: 12px; line-height:1.35; }
    .toast.good strong{ color: var(--good); }
    .toast.bad strong{ color: var(--bad); }
    .toast.warn strong{ color: var(--warn); }

    @media (max-width: 1060px){
      .shell{ grid-template-columns: 1fr; }
      .brand p{ display:none; }
      .chanList{ max-height: 320px; }
    }
  </style>
</head>

<body>
  <div class="grain"></div>

  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Twitch Clip Finder</h1>
          <p>Links: Kanäle (Follows/Favoriten). Mitte: Suche + „Mein Kanal“. Oben rechts: dein Profil nach Login.</p>
        </div>
      </div>

      <div class="actions">
        <div class="nav" role="tablist" aria-label="Ansichten">
          <button class="tab" id="tabSearch" role="tab" aria-selected="true">Suche</button>
          <button class="tab" id="tabMine" role="tab" aria-selected="false">Mein Kanal</button>
        </div>

        <button class="btn btnGhost" id="btnOpenSettings" type="button">Einstellungen</button>

        <div class="account" id="accountChip" style="display:none;">
          <div class="avatar" id="avatar"></div>
          <div class="accountText">
            <div class="name" id="accName">Angemeldet</div>
            <div class="sub" id="accSub">—</div>
          </div>
          <button class="btn btnGhost" id="btnLogout" type="button" style="padding:8px 10px; border-radius:999px;">Logout</button>
        </div>

        <button class="btn" id="btnLogin" type="button">Mit Twitch anmelden</button>
      </div>
    </div>

    <div class="shell">
      <!-- SIDEBAR -->
      <div class="card">
        <div class="cardHeader">
          <h2>Kanäle</h2>
          <div class="sideTop">
            <div class="sideTabs" role="tablist" aria-label="Sidebar Tabs">
              <button class="sideTab" id="sideTabFollows" aria-selected="true" type="button">Follows</button>
              <button class="sideTab" id="sideTabFavs" aria-selected="false" type="button">Favoriten</button>
            </div>
          </div>
        </div>
        <div class="cardBody">
          <label for="sideFilter">Suchen</label>
          <input id="sideFilter" placeholder="Kanal filtern…" autocomplete="off"/>

          <div style="display:flex; gap:10px; margin-top:10px;">
            <button class="btn btnGhost" id="btnRefreshSidebar" type="button" style="flex:1;">Aktualisieren</button>
            <button class="btn btnGhost" id="btnAddFav" type="button" style="flex:1;">+ Favorit</button>
          </div>

          <div class="muted" id="sideHint">
            Tipp: Für Follows brauchst du Scope <b>user:read:follows</b> und Login.
          </div>

          <div class="chanList" id="chanList"></div>
        </div>
      </div>

      <!-- MAIN CONTENT -->
      <div class="card">
        <div class="cardHeader">
          <h2 id="mainTitle">Suche</h2>
          <div class="statusLine">
            <span id="status">Bereit.</span>
            <span class="busy" id="busy"><span class="spinner"></span> lädt…</span>
            <button class="btn btnGhost" id="btnAbort" type="button" disabled>Stop</button>
          </div>
        </div>

        <div class="cardBody">
          <div class="err" id="error"></div>

          <!-- Search view -->
          <div id="viewSearch">
            <label for="searchLogin">Streamer (Loginname)</label>
            <input id="searchLogin" placeholder="z.B. schradin" autocomplete="off"/>

            <div class="row" style="margin-top:10px;">
              <div>
                <label for="from">Von (Datum+Uhrzeit)</label>
                <input id="from" type="datetime-local" />
              </div>
              <div>
                <label for="to">Bis (Datum+Uhrzeit)</label>
                <input id="to" type="datetime-local" />
              </div>
            </div>

            <button class="btn" id="btnSearch" type="button" style="margin-top:12px; width:100%;">Clips suchen</button>
            <div class="muted">Klick auf einen Kanal links setzt automatisch den Login in die Suche.</div>
          </div>

          <!-- Mine view -->
          <div id="viewMine" style="display:none;">
            <div class="muted" id="mineHint" style="margin-top:0;">
              Bitte zuerst anmelden, um deinen Kanal zu laden.
            </div>

            <div class="row" style="margin-top:10px;">
              <div>
                <label for="mineFrom">Von (Datum+Uhrzeit)</label>
                <input id="mineFrom" type="datetime-local" />
              </div>
              <div>
                <label for="mineTo">Bis (Datum+Uhrzeit)</label>
                <input id="mineTo" type="datetime-local" />
              </div>
            </div>

            <label style="margin-top:12px;">
              <input id="mineOnlyByMe" type="checkbox" style="width:auto; margin-right:8px; vertical-align: middle;">
              Nur Clips anzeigen, die ich erstellt habe (Filter)
            </label>

            <button class="btn" id="btnMine" type="button" style="margin-top:12px; width:100%;" disabled>Meine Kanal‑Clips laden</button>
          </div>
        </div>

        <div class="results" id="results"></div>
      </div>
    </div>
  </div>

  <!-- Settings Drawer -->
  <div class="drawerBackdrop" id="drawerBackdrop"></div>
  <aside class="drawer" id="drawer" aria-label="Einstellungen">
    <div class="drawerHead">
      <h3>Einstellungen</h3>
      <button class="btn btnGhost" id="btnCloseSettings" type="button">Schließen</button>
    </div>

    <div class="drawerBody">
      <div class="section">
        <h4>Twitch</h4>

        <label for="clientId">Client‑ID</label>
        <input id="clientId" placeholder="deine Twitch Client‑ID" autocomplete="off"/>

        <label for="scopes">Scopes (space-getrennt)</label>
        <input id="scopes" placeholder="z.B. user:read:follows" autocomplete="off"/>

        <div class="muted">
          Für Sidebar-Follows: <b>user:read:follows</b>.<br>
          Wenn du keine Scopes brauchst: Feld leer lassen.
        </div>

        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:12px;">
          <button class="btn btnGhost" id="btnPasteToken" type="button">Token einfügen</button>
          <button class="btn btnGhost" id="btnClearAll" type="button">Alles löschen</button>
        </div>
      </div>

      <div class="section">
        <h4>Hinweis</h4>
        <div class="muted">
          Token/Client-ID werden lokal im Browser gespeichert. Für private Nutzung ok.
        </div>
      </div>
    </div>
  </aside>

  <div class="toasts" id="toasts"></div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // Tabs
  const tabSearch = $("tabSearch");
  const tabMine = $("tabMine");
  const viewSearch = $("viewSearch");
  const viewMine = $("viewMine");
  const mainTitle = $("mainTitle");

  // Status
  const statusEl = $("status");
  const busyEl = $("busy");
  const errorEl = $("error");
  const resultsEl = $("results");

  const btnAbort = $("btnAbort");
  const btnSearch = $("btnSearch");
  const btnMine = $("btnMine");

  // Login UI
  const btnLogin = $("btnLogin");
  const btnLogout = $("btnLogout");
  const accountChip = $("accountChip");
  const avatar = $("avatar");
  const accName = $("accName");
  const accSub = $("accSub");
  const mineHint = $("mineHint");

  // Settings
  const btnOpenSettings = $("btnOpenSettings");
  const btnCloseSettings = $("btnCloseSettings");
  const drawer = $("drawer");
  const drawerBackdrop = $("drawerBackdrop");
  const clientIdInput = $("clientId");
  const scopesInput = $("scopes");
  const btnPasteToken = $("btnPasteToken");
  const btnClearAll = $("btnClearAll");

  // Inputs
  const searchLogin = $("searchLogin");
  const from = $("from");
  const to = $("to");
  const mineFrom = $("mineFrom");
  const mineTo = $("mineTo");
  const mineOnlyByMe = $("mineOnlyByMe");

  // Sidebar
  const sideTabFollows = $("sideTabFollows");
  const sideTabFavs = $("sideTabFavs");
  const sideFilter = $("sideFilter");
  const btnRefreshSidebar = $("btnRefreshSidebar");
  const btnAddFav = $("btnAddFav");
  const chanList = $("chanList");
  const sideHint = $("sideHint");

  // state
  let abortController = null;
  let me = null;
  let sidebarMode = "follows"; // follows | favs
  let followsCache = [];
  let favsCache = [];

  const LS = {
    clientId: "tcf_s_clientId",
    token: "tcf_s_token",
    scopes: "tcf_s_scopes",
    favs: "tcf_s_favs"
  };

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function toast(type, title, msg, ms=2600){
    const box = document.createElement("div");
    box.className = `toast ${type}`;
    box.innerHTML = `<strong>${escapeHtml(title)}</strong><span>${escapeHtml(msg)}</span>`;
    $("toasts").appendChild(box);
    setTimeout(() => {
      box.style.opacity = "0";
      box.style.transform = "translateY(6px)";
      box.style.transition = "opacity .18s ease, transform .18s ease";
      setTimeout(() => box.remove(), 220);
    }, ms);
  }

  function setBusy(isBusy){
    busyEl.style.display = isBusy ? "inline-flex" : "none";
    btnAbort.disabled = !isBusy;
    btnSearch.disabled = isBusy;
    btnMine.disabled = isBusy || !me;
    btnRefreshSidebar.disabled = isBusy;
  }
  function setStatus(msg){ statusEl.textContent = msg; }
  function setError(msg){ errorEl.textContent = msg || ""; }
  function clearResults(){ resultsEl.innerHTML = ""; }

  function toISO(dtLocal){
    const d = new Date(dtLocal);
    if (Number.isNaN(d.getTime())) return null;
    return d.toISOString();
  }
  function formatLocal(iso){ return new Date(iso).toLocaleString(); }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function openDrawer(){ document.body.classList.add("drawerOpen"); }
  function closeDrawer(){ document.body.classList.remove("drawerOpen"); }

  function getClientId(){ return (clientIdInput.value || "").trim(); }
  function getToken(){ return localStorage.getItem(LS.token) || ""; }
  function setToken(t){
    localStorage.setItem(LS.token, t || "");
  }
  function clearToken(){
    localStorage.removeItem(LS.token);
  }

  function showSkeletons(n=10){
    resultsEl.innerHTML = Array.from({length:n}).map(() => `
      <div class="skeleton">
        <div class="skThumb shimmer"></div>
        <div class="skLine shimmer"></div>
        <div class="skLine small shimmer"></div>
      </div>
    `).join("");
  }

  function* chunkRangeByHours(startMs, endMs, hours=24){
    const step = hours * 60 * 60 * 1000;
    for (let cur = startMs; cur < endMs; cur += step){
      yield [cur, Math.min(cur + step, endMs)];
    }
  }

  async function twitchFetch(url){
    const clientId = getClientId();
    const token = getToken();

    if (!clientId) throw new Error("Client-ID fehlt (Einstellungen).");
    if (!token) throw new Error("Nicht angemeldet (oder Token fehlt).");

    const res = await fetch(url, {
      headers: {
        "Client-ID": clientId,
        "Authorization": `Bearer ${token}`
      },
      signal: abortController?.signal
    });

    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}

    if (!res.ok){
      const msg = json?.message || json?.error || text || `HTTP ${res.status}`;
      throw new Error(`Twitch API Fehler: ${msg}`);
    }
    return json;
  }

  async function helix(path, params={}){
    const u = new URL("https://api.twitch.tv/helix" + path);
    for (const [k,v] of Object.entries(params)){
      if (v !== undefined && v !== null && v !== "") u.searchParams.set(k, String(v));
    }
    return twitchFetch(u.toString());
  }

  async function loadMe(){
    const json = await helix("/users");
    const user = json?.data?.[0];
    if (!user?.id) throw new Error("Account konnte nicht geladen werden. Token ungültig?");
    return user;
  }

  async function getUserByLogin(login){
    const json = await helix("/users", { login });
    const user = json?.data?.[0];
    if (!user?.id) throw new Error(`Kanal nicht gefunden: "${login}"`);
    return user;
  }

  async function getClipsForChunk(broadcasterId, startedAtISO, endedAtISO){
    const clips = [];
    let after = null;

    while (true){
      const json = await helix("/clips", {
        broadcaster_id: broadcasterId,
        started_at: startedAtISO,
        ended_at: endedAtISO,
        first: 100,
        after
      });

      const data = json?.data || [];
      clips.push(...data);

      after = json?.pagination?.cursor;
      if (!after || data.length === 0) break;

      await sleep(120);
    }

    return clips;
  }

  function renderClips(clips){
    clearResults();

    if (!clips.length){
      resultsEl.innerHTML = `<div class="muted" style="padding:6px 2px 14px;">Keine Clips im Zeitraum gefunden.</div>`;
      return;
    }

    clips.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));

    resultsEl.innerHTML = clips.map(c => {
      const thumb = (c.thumbnail_url || "").replace("%{width}","640").replace("%{height}","360");
      const title = escapeHtml(c.title || "(ohne Titel)");
      return `
        <a class="clip" href="${c.url}" target="_blank" rel="noopener">
          <div class="thumbWrap">
            <img class="thumb" src="${thumb}" alt="${title}" loading="lazy">
            <div class="thumbGrad"></div>
          </div>
          <div class="clipBody">
            <div class="clipTitle">${title}</div>
            <div class="meta">
              <span class="tag"><strong>${escapeHtml(formatLocal(c.created_at))}</strong></span>
              <span class="tag">Views <strong>${escapeHtml(String(c.view_count ?? "?"))}</strong></span>
              <span class="tag">Creator <strong>${escapeHtml(c.creator_name ?? "?")}</strong></span>
            </div>
          </div>
        </a>
      `;
    }).join("");
  }

  async function runSearchForBroadcaster(broadcasterId, startedAtISO, endedAtISO, creatorId=null){
    const startedMs = new Date(startedAtISO).getTime();
    const endedMs   = new Date(endedAtISO).getTime();
    const all = [];
    const seen = new Set();

    const chunks = Array.from(chunkRangeByHours(startedMs, endedMs, 24));
    for (let i=0; i<chunks.length; i++){
      const [a,b] = chunks[i];
      setStatus(`Lade Clips… Block ${i+1}/${chunks.length}`);
      const clips = await getClipsForChunk(broadcasterId, new Date(a).toISOString(), new Date(b).toISOString());
      for (const c of clips){
        if (!seen.has(c.id)){
          seen.add(c.id);
          all.push(c);
        }
      }
    }

    return creatorId ? all.filter(c => c.creator_id === creatorId) : all;
  }

  /* ---------- OAuth ---------- */
  function parseOAuthHash(){
    if (!location.hash || !location.hash.includes("access_token=")) return false;
    const hash = location.hash.startsWith("#") ? location.hash.slice(1) : location.hash;
    const params = new URLSearchParams(hash);

    const accessToken = params.get("access_token");
    const scope = params.get("scope"); // optional
    if (accessToken){
      setToken(accessToken);
      if (scope != null) localStorage.setItem(LS.scopes, scope);
      toast("good", "Login", "Token übernommen.");
    }
    history.replaceState(null, "", location.pathname + location.search);
    return true;
  }

  function buildAuthorizeUrl(){
    const clientId = getClientId();
    if (!clientId) throw new Error("Client-ID fehlt (Einstellungen).");

    const redirectUri = location.origin + location.pathname; // must match Twitch app redirect URL
    const state = Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
    const scope = (scopesInput.value || "").trim(); // space-separated

    let url =
      "https://id.twitch.tv/oauth2/authorize" +
      `?client_id=${encodeURIComponent(clientId)}` +
      `&redirect_uri=${encodeURIComponent(redirectUri)}` +
      `&response_type=token` +
      `&state=${encodeURIComponent(state)}`;

    // IMPORTANT: Only add scope if non-empty (prevents "invalid scope" when wrong stuff is in field)
    if (scope) url += `&scope=${encodeURIComponent(scope)}`;

    return url;
  }

  function setAccountUI(user){
    me = user;

    btnLogin.style.display = me ? "none" : "";
    accountChip.style.display = me ? "flex" : "none";
    btnMine.disabled = !me;

    if (me){
      accName.textContent = me.display_name || me.login || "Angemeldet";
      accSub.textContent = `@${me.login} • id ${me.id}`;
      mineHint.innerHTML = `Angemeldet als <b>@${escapeHtml(me.login)}</b>.`;
      avatar.innerHTML = me.profile_image_url ? `<img src="${escapeHtml(me.profile_image_url)}" alt="">` : "";
    } else {
      avatar.innerHTML = "";
      mineHint.textContent = "Bitte zuerst anmelden, um deinen Kanal zu laden.";
    }
  }

  /* ---------- Sidebar: Follows + Favorites ---------- */
  function loadFavs(){
    try{
      const raw = localStorage.getItem(LS.favs);
      const arr = raw ? JSON.parse(raw) : [];
      favsCache = Array.isArray(arr) ? arr : [];
    } catch {
      favsCache = [];
    }
  }
  function saveFavs(){
    localStorage.setItem(LS.favs, JSON.stringify(favsCache));
  }

  function setSidebarMode(mode){
    sidebarMode = mode;
    sideTabFollows.setAttribute("aria-selected", String(mode === "follows"));
    sideTabFavs.setAttribute("aria-selected", String(mode === "favs"));
    renderSidebar();
  }

  function renderSidebar(){
    const q = (sideFilter.value || "").trim().toLowerCase();
    const list = sidebarMode === "follows" ? followsCache : favsCache;

    const filtered = list.filter(x => {
      const name = (x.display_name || x.broadcaster_name || x.login || "").toLowerCase();
      const login = (x.login || x.broadcaster_login || "").toLowerCase();
      return !q || name.includes(q) || login.includes(q);
    });

    if (sidebarMode === "follows"){
      sideHint.innerHTML = me
        ? `Follows für <b>@${escapeHtml(me.login)}</b>.`
        : `Bitte anmelden. Für Follows brauchst du Scope <b>user:read:follows</b>.`;
    } else {
      sideHint.textContent = "Favoriten sind lokal gespeichert (nur in deinem Browser).";
    }

    if (!filtered.length){
      chanList.innerHTML = `<div class="muted" style="padding:6px 2px;">Keine Einträge.</div>`;
      return;
    }

    chanList.innerHTML = filtered.map(ch => {
      const login = ch.login || ch.broadcaster_login || "";
      const name = ch.display_name || ch.broadcaster_name || login || "—";
      const img = ch.profile_image_url ? `<img src="${escapeHtml(ch.profile_image_url)}" alt="">` : "";
      return `
        <div class="chan" data-login="${escapeHtml(login)}">
          <div class="chanAva">${img}</div>
          <div class="chanTxt">
            <div class="t">${escapeHtml(name)}</div>
            <div class="s">@${escapeHtml(login)}</div>
          </div>
          <div class="badgeLive">Clip-Suche</div>
        </div>
      `;
    }).join("");
  }

  async function loadFollows(){
    followsCache = [];
    if (!me) return;

    // /channels/followed requires scope user:read:follows (or it will 401/403)
    let after = null;
    const all = [];
    for (let page=0; page<3; page++){ // safety cap
      const json = await helix("/channels/followed", { user_id: me.id, first: 100, after });
      const data = json?.data || [];
      all.push(...data);
      after = json?.pagination?.cursor;
      if (!after || data.length === 0) break;
      await sleep(120);
    }

    // fetch user avatars for those broadcaster_ids
    const ids = all.map(x => x.broadcaster_id).filter(Boolean);
    const idToUser = new Map();

    for (let i=0; i<ids.length; i+=100){
      const chunk = ids.slice(i, i+100);
      const u = new URL("https://api.twitch.tv/helix/users");
      chunk.forEach(id => u.searchParams.append("id", id));
      const j = await twitchFetch(u.toString());
      (j?.data || []).forEach(u => idToUser.set(u.id, u));
      await sleep(120);
    }

    followsCache = all.map(f => {
      const u = idToUser.get(f.broadcaster_id);
      return {
        broadcaster_id: f.broadcaster_id,
        broadcaster_login: f.broadcaster_login,
        broadcaster_name: f.broadcaster_name,
        login: f.broadcaster_login,
        display_name: u?.display_name || f.broadcaster_name,
        profile_image_url: u?.profile_image_url || ""
      };
    });

    followsCache.sort((a,b) => (a.login||"").localeCompare(b.login||""));
  }

  /* ---------- Main actions ---------- */
  function setTab(which){
    const isSearch = which === "search";
    tabSearch.setAttribute("aria-selected", String(isSearch));
    tabMine.setAttribute("aria-selected", String(!isSearch));
    viewSearch.style.display = isSearch ? "" : "none";
    viewMine.style.display = isSearch ? "none" : "";
    mainTitle.textContent = isSearch ? "Suche" : "Mein Kanal";
    setError("");
    clearResults();
    setStatus("Bereit.");
  }

  async function doSearch(){
    setError("");
    clearResults();

    const login = searchLogin.value.trim();
    const fromISO = toISO(from.value);
    const toISOv  = toISO(to.value);

    if (!login) { setError("Bitte Streamer‑Login eingeben (oder links anklicken)."); return; }
    if (!fromISO || !toISOv) { setError("Bitte Von/Bis auswählen."); return; }

    const fromMs = new Date(fromISO).getTime();
    const toMs = new Date(toISOv).getTime();
    if (!(toMs > fromMs)) { setError("'Bis' muss nach 'Von' liegen."); return; }

    abortController = new AbortController();
    setBusy(true);
    showSkeletons(10);

    try{
      setStatus("Lade Kanal…");
      const user = await getUserByLogin(login);

      setStatus(`Suche Clips für ${user.display_name}…`);
      const clips = await runSearchForBroadcaster(user.id, fromISO, toISOv);

      setStatus(`Fertig. ${clips.length} Clips.`);
      renderClips(clips);
    } catch(e){
      setStatus("Fehler.");
      setError(e?.message || String(e));
      toast("bad", "Fehler", e?.message || String(e));
    } finally {
      setBusy(false);
      abortController = null;
    }
  }

  async function doMine(){
    setError("");
    clearResults();

    if (!me){
      setError("Bitte zuerst anmelden.");
      return;
    }

    const fromISO = toISO(mineFrom.value);
    const toISOv  = toISO(mineTo.value);

    if (!fromISO || !toISOv) { setError("Bitte Von/Bis auswählen."); return; }

    const fromMs = new Date(fromISO).getTime();
    const toMs = new Date(toISOv).getTime();
    if (!(toMs > fromMs)) { setError("'Bis' muss nach 'Von' liegen."); return; }

    abortController = new AbortController();
    setBusy(true);
    showSkeletons(10);

    try{
      setStatus("Lade meine Clips…");
      const clips = await runSearchForBroadcaster(me.id, fromISO, toISOv, mineOnlyByMe.checked ? me.id : null);
      setStatus(`Fertig. ${clips.length} Clips.`);
      renderClips(clips);
    } catch(e){
      setStatus("Fehler.");
      setError(e?.message || String(e));
      toast("bad", "Fehler", e?.message || String(e));
    } finally {
      setBusy(false);
      abortController = null;
    }
  }

  async function refreshMeAndSidebar(){
    if (!getToken()){
      setAccountUI(null);
      followsCache = [];
      renderSidebar();
      return;
    }

    abortController = new AbortController();
    setBusy(true);

    try{
      setStatus("Prüfe Login…");
      const user = await loadMe();
      setAccountUI(user);

      setStatus("Lade Sidebar…");
      try{
        await loadFollows();
      } catch(e){
        // typical: missing scope -> 401/403
        followsCache = [];
        toast("warn", "Follows nicht verfügbar", "Fehlt Scope user:read:follows? Dann in Einstellungen eintragen und neu anmelden.");
      }

      renderSidebar();
      setStatus("Bereit.");
    } catch(e){
      clearToken();
      setAccountUI(null);
      followsCache = [];
      renderSidebar();
      setStatus("Bereit.");
      toast("warn", "Login abgelaufen", "Bitte erneut anmelden.");
    } finally {
      setBusy(false);
      abortController = null;
    }
  }

  /* ---------- Events ---------- */
  tabSearch.addEventListener("click", () => setTab("search"));
  tabMine.addEventListener("click", () => setTab("mine"));

  btnAbort.addEventListener("click", () => abortController?.abort());
  btnSearch.addEventListener("click", doSearch);
  btnMine.addEventListener("click", doMine);

  btnOpenSettings.addEventListener("click", openDrawer);
  btnCloseSettings.addEventListener("click", closeDrawer);
  drawerBackdrop.addEventListener("click", closeDrawer);

  btnLogin.addEventListener("click", () => {
    try{
      localStorage.setItem(LS.clientId, getClientId());
      localStorage.setItem(LS.scopes, (scopesInput.value || "").trim());
      window.location.href = buildAuthorizeUrl();
    } catch(e){
      setError(e?.message || String(e));
      toast("bad", "Einstellungen", e?.message || String(e));
    }
  });

  btnLogout.addEventListener("click", () => {
    clearToken();
    setAccountUI(null);
    followsCache = [];
    renderSidebar();
    toast("good", "Logout", "Token entfernt.");
    setStatus("Bereit.");
    clearResults();
    setError("");
  });

  btnPasteToken.addEventListener("click", async () => {
    const t = prompt("Token einfügen (ohne 'Bearer '):");
    if (!t) return;
    setToken(t.trim());
    toast("good", "Token gesetzt", "Prüfe Login…");
    await refreshMeAndSidebar();
  });

  btnClearAll.addEventListener("click", () => {
    localStorage.removeItem(LS.clientId);
    localStorage.removeItem(LS.scopes);
    localStorage.removeItem(LS.favs);
    clearToken();
    clientIdInput.value = "";
    scopesInput.value = "";
    favsCache = [];
    followsCache = [];
    setAccountUI(null);
    renderSidebar();
    toast("good", "Zurückgesetzt", "Lokale Daten gelöscht.");
  });

  sideTabFollows.addEventListener("click", () => setSidebarMode("follows"));
  sideTabFavs.addEventListener("click", () => setSidebarMode("favs"));

  sideFilter.addEventListener("input", renderSidebar);

  btnRefreshSidebar.addEventListener("click", async () => {
    setError("");
    await refreshMeAndSidebar();
  });

  btnAddFav.addEventListener("click", () => {
    const login = prompt("Favorit hinzufügen (Loginname, z.B. schradin):");
    if (!login) return;
    const clean = login.trim().toLowerCase();
    if (!clean) return;

    if (!favsCache.some(x => (x.login||"").toLowerCase() === clean)){
      favsCache.unshift({ login: clean, display_name: clean, profile_image_url: "" });
      saveFavs();
      toast("good", "Favorit", `@${clean} hinzugefügt.`);
      renderSidebar();
    }
  });

  chanList.addEventListener("click", (e) => {
    const item = e.target.closest(".chan");
    if (!item) return;
    const login = item.getAttribute("data-login") || "";
    if (!login) return;

    searchLogin.value = login;
    setTab("search");
    toast("good", "Kanal gewählt", `@${login} in die Suche übernommen.`);
    // optional: direkt starten:
    // doSearch();
  });

  // persist settings
  clientIdInput.addEventListener("input", () => localStorage.setItem(LS.clientId, getClientId()));
  scopesInput.addEventListener("input", () => localStorage.setItem(LS.scopes, (scopesInput.value||"").trim()));

  // defaults
  const now = new Date();
  const oneHourAgo = new Date(now.getTime() - 60*60*1000);
  to.value = now.toISOString().slice(0,16);
  from.value = oneHourAgo.toISOString().slice(0,16);
  mineTo.value = to.value;
  mineFrom.value = from.value;

  // restore
  const savedClientId = localStorage.getItem(LS.clientId);
  const savedScopes = localStorage.getItem(LS.scopes);
  if (savedClientId) clientIdInput.value = savedClientId;
  if (savedScopes) scopesInput.value = savedScopes;

  // favorites init
  loadFavs();
  renderSidebar();

  // parse oauth token and init
  parseOAuthHash();
  setTab("search");
  refreshMeAndSidebar();

})();
</script>
</body>
</html>

